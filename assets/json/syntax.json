[{"word": "name", "info": "This defines the name shown for the syntax in the menu. It\u2019s optional, and will be derived from the file name if not used.", "menu": "syntax"}, {"word": "file_extensions", "info": "A list of strings, defining file extensions this syntax should be used for. Extensions listed here will be shown in file dialog dropdowns on some operating systems. If a file does not have a basename, e.g. .gitignore, the entirety of the filename including the leading . should be specified.", "menu": "syntax"}, {"word": "hidden_file_extensions", "info": "A list of strings, also defining file extensions this syntax should be used for. These extensions are not listed in file dialogs.", "menu": "syntax"}, {"word": "first_line_match", "info": "When a file is opened without a recognized extension, the first line of the file contents will be tested against this regex, to see if the syntax should be applied.", "menu": "syntax"}, {"word": "scope", "info": "The default scope assigned to all text in the file", "menu": "syntax"}, {"word": "version", "info": "An integer, either 1 or 2, that controls backwards compatibility. New syntaxes should target 2, as it fixes some inconsistencies in how scopes are applied.", "menu": "syntax"}, {"word": "extends", "info": "A string of a base syntax this syntax should inherit from. The base syntax must be specified using its package path, e.g. Packages/JavaScript/JavaScript.sublime-syntax. See Inheritance for an overview of syntax inheritance.", "menu": "syntax"}, {"word": "hidden", "info": "Hidden syntax definitions won\u2019t be shown in the menu, but can still be assigned by plugins, or included by other syntax definitions.", "menu": "syntax"}, {"word": "meta_scope", "info": "This assigns the given scope to all text within this context, including the patterns that push the context onto the stack and pop it off.", "menu": "syntax"}, {"word": "meta_content_scope", "info": "As above, but does not apply to the text that triggers the context (e.g., in the above string example, the content scope would not get applied to the quote characters).", "menu": "syntax"}, {"word": "meta_include_prototype", "info": "Used to stop the current context from automatically including the prototype context.", "menu": "syntax"}, {"word": "clear_scopes", "info": "This setting allows removing scope names from the current stack. It can be an integer, or the value true to remove all scope names. It is applied before meta_scope and meta_content_scope. This is typically only used when one syntax is embedding another.", "menu": "syntax"}, {"word": "meta_prepend", "info": "A boolean, controlling context name conflict resolution during inheritance. If this is specified, the rules in this context will be inserted before any existing rules from a context with the same name in an ancestor syntax definition.", "menu": "syntax"}, {"word": "meta_append", "info": "A boolean, controlling context name conflict resolution during inheritance. If this is specified, the rules in this context will be inserted after to any existing rules from a context with the same name in an ancestor syntax definition.", "menu": "syntax"}, {"word": "match", "info": "The regex used to match against the text. YAML allows many strings to be written without quotes, which can help make the regex clearer, but it\u2019s important to understand when you need to quote the regex. If your regex includes the characters #, :, -, {, [ or > then you likely need to quote it. Regexes are only ever run against a single line of text at a time.", "menu": "syntax"}, {"word": "scope", "info": "The scope assigned to the matched text.", "menu": "syntax"}, {"word": "captures", "info": "A mapping of numbers to scope, assigning scopes to captured portions of the match regex. See below for an example.", "menu": "syntax"}, {"word": "push", "info": "The contexts to push onto the stack. This may be either a single context name, a list of context names, or an inline, anonymous context.", "menu": "syntax"}, {"word": "pop", "info": "Pops contexts off the stack. The value true will pop a single context.  An integer greater than zero will pop the corresponding number of contexts. 4050  The pop key can be combined with push, set, embed and branch. When combined, the specified number of contexts will be popped off of the stack before the other action is performed. For push, embed and branch actions, the pop treats the match as if it were a lookahead, which means the match will not receive the meta_scope of the contexts that are popped. 4075", "menu": "syntax"}, {"word": "set", "info": "Accepts the same arguments as push, but will first pop this context off, and then push the given context(s) onto the stack. Any match will receive the meta_scope of the context being popped and the context being pushed.", "menu": "syntax"}, {"word": "embed", "info": "Accepts the name of a single context to push into. While similar to push, it pops out of any number of nested contexts as soon as the escape pattern is found. This makes it an ideal tool for embedding one syntax within another.   escape This key is required if embed is used, and is a regex used to exit from the embedded context. Any backreferences in this pattern will refer to capture groups in the match regex.    embed_scope A scope assigned to all text matched after the match and before the escape. Similar in concept to meta_content_scope.    escape_captures A mapping of capture groups to scope names, for the escape pattern. Use capture group 0 to apply a scope to the entire escape match.", "menu": "syntax"}, {"word": "escape", "info": "This key is required if embed is used, and is a regex used to exit from the embedded context. Any backreferences in this pattern will refer to capture groups in the match regex.", "menu": "syntax"}, {"word": "embed_scope", "info": "A scope assigned to all text matched after the match and before the escape. Similar in concept to meta_content_scope.", "menu": "syntax"}, {"word": "escape_captures", "info": "A mapping of capture groups to scope names, for the escape pattern. Use capture group 0 to apply a scope to the entire escape match.", "menu": "syntax"}, {"word": "branch", "info": "Accepts the names of two or more contexts, which are attempted in order. If a fail action is encountered, the highlighting of the file will be restarted at the character where the branch occured, and the next context will be attempted.   branch_point This is the unique identifier for the branch and is specified when a match uses the fail action.  The branch action allows for handling syntax constructs that are ambiguous, and also allows handling constructs that span multiple lines. For ideal performance, the contexts should be listed in the order of how likely they are to be accepted. Note: because highlighting with branches requires reprocessing an entire branch upon each change to the document, the highlighting engine will not rewind more than 128 lines when a fail occurs.", "menu": "syntax"}, {"word": "branch_point", "info": "This is the unique identifier for the branch and is specified when a match uses the fail action.", "menu": "syntax"}, {"word": "fail", "info": "Accepts the name of a branch_point to rewind to and retry the next context of. If a fail action specifies a branch_point that was never pushed on the stack, or has already been popped off of the stack, it will have no effect.", "menu": "syntax"}]