[{"word": "comment.line", "info": "Single and multi-line comments should use, respectively:"}, {"word": "comment.block", "info": "Single and multi-line comments should use, respectively:"}, {"word": "comment.block.documentation", "info": "Multi-line comments used as documentation, such as Javadoc or PhpDoc, should use:"}, {"word": "constant.numeric", "info": "Numeric literals, including integers, floats, etc. should use one of:"}, {"word": "constant.numeric.integer", "info": "Numeric literals, including integers, floats, etc. should use one of:"}, {"word": "constant.numeric.integer.binary", "info": "Numeric literals, including integers, floats, etc. should use one of:"}, {"word": "constant.numeric.integer.octal", "info": "Numeric literals, including integers, floats, etc. should use one of:"}, {"word": "constant.numeric.integer.decimal", "info": "Numeric literals, including integers, floats, etc. should use one of:"}, {"word": "constant.numeric.integer.hexadecimal", "info": "Numeric literals, including integers, floats, etc. should use one of:"}, {"word": "constant.numeric.integer.other", "info": "Numeric literals, including integers, floats, etc. should use one of:"}, {"word": "constant.numeric.float", "info": "Numeric literals, including integers, floats, etc. should use one of:"}, {"word": "constant.numeric.float.binary", "info": "Numeric literals, including integers, floats, etc. should use one of:"}, {"word": "constant.numeric.float.octal", "info": "Numeric literals, including integers, floats, etc. should use one of:"}, {"word": "constant.numeric.float.decimal", "info": "Numeric literals, including integers, floats, etc. should use one of:"}, {"word": "constant.numeric.float.hexadecimal", "info": "Numeric literals, including integers, floats, etc. should use one of:"}, {"word": "constant.numeric.float.other", "info": "Numeric literals, including integers, floats, etc. should use one of:"}, {"word": "constant.numeric.complex", "info": "Numeric literals, including integers, floats, etc. should use one of:"}, {"word": "constant.numeric.complex.real", "info": "Numeric literals, including integers, floats, etc. should use one of:"}, {"word": "constant.numeric.complex.imaginary", "info": "Numeric literals, including integers, floats, etc. should use one of:"}, {"word": "constant.language", "info": "Constants that are built into the language, such as booleans and null values,\nshould use:"}, {"word": "constant.character.escape", "info": "Character escapes in strings, e.g. \\n and \\x20, should use:"}, {"word": "constant.other.placeholder", "info": "Formatting placeholders, such as those used for sprintf(), e.g. %s,\nshould use:"}, {"word": "constant.other", "info": "Other language-specific constant values, such as symbols in Ruby, should use:"}, {"word": "entity.name.class", "info": "Avoid entity.name.type.class and entity.name.type.struct which\nunnecessarily nest scope labels under type."}, {"word": "entity.name.struct", "info": "Avoid entity.name.type.class and entity.name.type.struct which\nunnecessarily nest scope labels under type."}, {"word": "entity.name.enum", "info": "Avoid entity.name.type.class and entity.name.type.struct which\nunnecessarily nest scope labels under type."}, {"word": "entity.name.union", "info": "Avoid entity.name.type.class and entity.name.type.struct which\nunnecessarily nest scope labels under type."}, {"word": "entity.name.trait", "info": "Avoid entity.name.type.class and entity.name.type.struct which\nunnecessarily nest scope labels under type."}, {"word": "entity.name.interface", "info": "Avoid entity.name.type.class and entity.name.type.struct which\nunnecessarily nest scope labels under type."}, {"word": "entity.name.impl", "info": "Avoid entity.name.type.class and entity.name.type.struct which\nunnecessarily nest scope labels under type."}, {"word": "entity.name.type", "info": "Avoid entity.name.type.class and entity.name.type.struct which\nunnecessarily nest scope labels under type."}, {"word": "entity.name.class.forward-decl", "info": "forward-decl variants of the above are used in languages such as C and C++.\nSuch scopes can be used to exclude identifiers from the symbol list and\nindexing."}, {"word": "entity.other.inherited-class", "info": "Class, interface and trait names listed as an inherited class or implemented\ninterface/trait should use:"}, {"word": "entity.name.function", "info": "Function names receive one of the following scopes. These are included in the\nsymbol list and index."}, {"word": "entity.name.function.constructor", "info": "Function names receive one of the following scopes. These are included in the\nsymbol list and index."}, {"word": "entity.name.function.destructor", "info": "Function names receive one of the following scopes. These are included in the\nsymbol list and index."}, {"word": "entity.name.namespace", "info": "Namespaces, packages and modules use the following scope. There are usually not\nmultiple types of such constructs in a language, so this scope should suffice."}, {"word": "entity.name.constant", "info": "Constants should use the following scope or variable.other.constant,\ndepending on the language semantics. This scope is often included in the symbol\nlist and index."}, {"word": "entity.name.label", "info": "Labels for goto-like constructs should use:"}, {"word": "entity.name.section", "info": "Heading names in markup languages, such as Markdown and Textile, should use:"}, {"word": "entity.name.tag", "info": "HTML and XML tags should use the following scope. This is the only\nentity.name scope that is applied to repeated constructs."}, {"word": "entity.other.attribute-name", "info": "HTML, CSS and XML use the following for tag attribute names:"}, {"word": "invalid.illegal", "info": "Elements that are illegal in a specific context should use the following scope.\nOveruse of this will likely lead to unpleasant highlighting for users as they\nedit code."}, {"word": "invalid.deprecated", "info": "Deprecated elements should be scoped using the following scope. This should be\nvery rarely used, as users may be working with older versions of a language."}, {"word": "keyword.control", "info": "Control keywords examples include if, try, end and while. Some\nsyntaxes prefer to mark if and else with the conditional variant.\nThe import variant is often used in appropriate situations."}, {"word": "keyword.control.conditional", "info": "Control keywords examples include if, try, end and while. Some\nsyntaxes prefer to mark if and else with the conditional variant.\nThe import variant is often used in appropriate situations."}, {"word": "keyword.control.import", "info": "Control keywords examples include if, try, end and while. Some\nsyntaxes prefer to mark if and else with the conditional variant.\nThe import variant is often used in appropriate situations."}, {"word": "keyword.other", "info": "All remaining non-operator keywords fall under the other variant:"}, {"word": "keyword.operator", "info": "Operators are typically symbols, so the term keyword can seem somewhat\ncontradictory. Specific variants are sometimes referenced based on the type of\noperator."}, {"word": "keyword.operator.assignment", "info": "Operators are typically symbols, so the term keyword can seem somewhat\ncontradictory. Specific variants are sometimes referenced based on the type of\noperator."}, {"word": "keyword.operator.arithmetic", "info": "Operators are typically symbols, so the term keyword can seem somewhat\ncontradictory. Specific variants are sometimes referenced based on the type of\noperator."}, {"word": "keyword.operator.bitwise", "info": "Operators are typically symbols, so the term keyword can seem somewhat\ncontradictory. Specific variants are sometimes referenced based on the type of\noperator."}, {"word": "keyword.operator.logical", "info": "Operators are typically symbols, so the term keyword can seem somewhat\ncontradictory. Specific variants are sometimes referenced based on the type of\noperator."}, {"word": "keyword.operator.word", "info": "When the operator is a word, such as and, or or not, the following\nvariant is used:"}, {"word": "markup.heading", "info": "Section headings should use:"}, {"word": "markup.list.unnumbered", "info": "Lists should use one of:"}, {"word": "markup.list.numbered", "info": "Lists should use one of:"}, {"word": "markup.bold", "info": "Basic text styling should use one of:"}, {"word": "markup.italic", "info": "Basic text styling should use one of:"}, {"word": "markup.underline", "info": "Basic text styling should use one of:"}, {"word": "markup.inserted", "info": "Inserted and deleted content, such as with diff output, should use:"}, {"word": "markup.deleted", "info": "Inserted and deleted content, such as with diff output, should use:"}, {"word": "markup.underline.link", "info": "Links should use:"}, {"word": "markup.quote", "info": "Blockquotes and other quote styles should use:"}, {"word": "markup.raw.inline", "info": "Inline and block literal quoting, often used for code, should use:"}, {"word": "markup.raw.block", "info": "Inline and block literal quoting, often used for code, should use:"}, {"word": "markup.other", "info": "Other markup, including constructs such as footnotes and tables, should use:"}, {"word": "meta.class", "info": "The complete contents of data structures should be scoped using one of the\nfollowing scopes. Similar to entity.name, they should be customized per\nlanguage to provide rich semantic information. They should include all\nelements, such as the name, inheritance details and body."}, {"word": "meta.struct", "info": "The complete contents of data structures should be scoped using one of the\nfollowing scopes. Similar to entity.name, they should be customized per\nlanguage to provide rich semantic information. They should include all\nelements, such as the name, inheritance details and body."}, {"word": "meta.enum", "info": "The complete contents of data structures should be scoped using one of the\nfollowing scopes. Similar to entity.name, they should be customized per\nlanguage to provide rich semantic information. They should include all\nelements, such as the name, inheritance details and body."}, {"word": "meta.union", "info": "The complete contents of data structures should be scoped using one of the\nfollowing scopes. Similar to entity.name, they should be customized per\nlanguage to provide rich semantic information. They should include all\nelements, such as the name, inheritance details and body."}, {"word": "meta.trait", "info": "The complete contents of data structures should be scoped using one of the\nfollowing scopes. Similar to entity.name, they should be customized per\nlanguage to provide rich semantic information. They should include all\nelements, such as the name, inheritance details and body."}, {"word": "meta.interface", "info": "The complete contents of data structures should be scoped using one of the\nfollowing scopes. Similar to entity.name, they should be customized per\nlanguage to provide rich semantic information. They should include all\nelements, such as the name, inheritance details and body."}, {"word": "meta.impl", "info": "The complete contents of data structures should be scoped using one of the\nfollowing scopes. Similar to entity.name, they should be customized per\nlanguage to provide rich semantic information. They should include all\nelements, such as the name, inheritance details and body."}, {"word": "meta.type", "info": "The complete contents of data structures should be scoped using one of the\nfollowing scopes. Similar to entity.name, they should be customized per\nlanguage to provide rich semantic information. They should include all\nelements, such as the name, inheritance details and body."}, {"word": "meta.function", "info": "The entire scope of a function should be covered by one of the following scopes.\nEach variant should be applied to a specific part, and not stacked. For\nexample, meta.function.php meta.function.parameters.php should never occur,\nbut instead the scopes should alternate between meta.function.php then\nmeta.function.parameters.php and back to meta.function.php."}, {"word": "meta.function.parameters", "info": "The entire scope of a function should be covered by one of the following scopes.\nEach variant should be applied to a specific part, and not stacked. For\nexample, meta.function.php meta.function.parameters.php should never occur,\nbut instead the scopes should alternate between meta.function.php then\nmeta.function.parameters.php and back to meta.function.php."}, {"word": "meta.function.return-type", "info": "The entire scope of a function should be covered by one of the following scopes.\nEach variant should be applied to a specific part, and not stacked. For\nexample, meta.function.php meta.function.parameters.php should never occur,\nbut instead the scopes should alternate between meta.function.php then\nmeta.function.parameters.php and back to meta.function.php."}, {"word": "meta.namespace", "info": "The entirety of a namespace, module or package should use:"}, {"word": "meta.preprocessor", "info": "Preprocessor statements in language such as C should use:"}, {"word": "meta.annotation", "info": "Annotations, attributes and decorator statements that are used to modify the\nbehavior or implementation of a class, method or function should use one of the\nfollowing meta scopes for each component of the annotation. That is to say,\nthere should never be more than one meta.annotation* scope on the stack at\nany given time. See variable.annotation for scoping the identifier."}, {"word": "meta.annotation.identifier", "info": "Annotations, attributes and decorator statements that are used to modify the\nbehavior or implementation of a class, method or function should use one of the\nfollowing meta scopes for each component of the annotation. That is to say,\nthere should never be more than one meta.annotation* scope on the stack at\nany given time. See variable.annotation for scoping the identifier."}, {"word": "meta.annotation.parameters", "info": "Annotations, attributes and decorator statements that are used to modify the\nbehavior or implementation of a class, method or function should use one of the\nfollowing meta scopes for each component of the annotation. That is to say,\nthere should never be more than one meta.annotation* scope on the stack at\nany given time. See variable.annotation for scoping the identifier."}, {"word": "meta.path", "info": "Complete identifiers, including namespace names, should use the following scope.\nSuch identifiers are the fully-qualified forms of variable, function and class\nnames. For example, in C++ a path may look like myns::myclass, whereas in\nPHP it would appears such as \\MyNS\\MyClass."}, {"word": "meta.function-call", "info": "Function names, including the full path, and all parameters should receive the\nfollowing scope. The name of the function or method should be\nvariable.function, unless the function is scoped with\nsupport.function."}, {"word": "meta.block", "info": "Sections of code delineated by curly braces should use one the following\nmeta scopes, based on appropriate semantics. The { and } characters\nshould additionally use the punctuation scopes."}, {"word": "meta.braces", "info": "Sections of code delineated by curly braces should use one the following\nmeta scopes, based on appropriate semantics. The { and } characters\nshould additionally use the punctuation scopes."}, {"word": "meta.group", "info": "Sections of code delineated by parentheses should use one the following meta\nscopes, based on appropriate semantics. The ( and ) characters should\nadditionally use the punctuation scopes."}, {"word": "meta.parens", "info": "Sections of code delineated by parentheses should use one the following meta\nscopes, based on appropriate semantics. The ( and ) characters should\nadditionally use the punctuation scopes."}, {"word": "meta.brackets", "info": "Sections of code delineated by square brackets should use the following scope.\nThe [ and ] characters should additionally use the punctuation\nscopes."}, {"word": "meta.generic", "info": "Generic data type constructs should use the following scope. Any symbols that\ndenote the beginning and end, such as < and >, should\nadditionally use the punctuation scopes."}, {"word": "meta.tag", "info": "HTML and XML tags, including punctuation, names and attributes should use the\nfollowing:"}, {"word": "meta.paragraph", "info": "Paragraphs in markup languages use:"}, {"word": "punctuation.separator", "info": "Separators such as commas and colons should use:"}, {"word": "punctuation.terminator", "info": "Semicolons or other statement terminators should use:"}, {"word": "punctuation.separator.continuation", "info": "Line-continuation characters, such as in Python and R, should use:"}, {"word": "punctuation.accessor", "info": "Member access, scope resolution, or similar constructs should use the following\nscope. For Python or JavaScript this would be .. In PHP this would be\napplied to -> and ::. In C++, this would be applied to all three."}, {"word": "source", "info": "A language-specific variant of the following scope is typically applied to the\nentirety of a source code file:"}, {"word": "storage.type", "info": "Types should use the following scope. Examples include int, bool and\nchar."}, {"word": "storage.modifier", "info": "Keywords that affect the storage of a variable, function or data structure\nshould use the following scope. Examples include static, inline,\nconst, public and private."}, {"word": "storage.type.function keyword.declaration.function", "info": "Keywords for functions or methods should use the following scopes. Example\nkeywords include func, function and def. This includes\nstorage.type for backwards compatibility with older color schemes."}, {"word": "storage.type.class keyword.declaration.class", "info": "Keywords for classes, structs, interfaces, etc should use the following scopes \u2013\nthis list is not exhaustive. Example keywords include class, struct,\nimpl and typedef. This includes storage.type for backwards\ncompatibility with older color schemes."}, {"word": "storage.type.struct keyword.declaration.struct", "info": "Keywords for classes, structs, interfaces, etc should use the following scopes \u2013\nthis list is not exhaustive. Example keywords include class, struct,\nimpl and typedef. This includes storage.type for backwards\ncompatibility with older color schemes."}, {"word": "storage.type.enum keyword.declaration.enum", "info": "Keywords for classes, structs, interfaces, etc should use the following scopes \u2013\nthis list is not exhaustive. Example keywords include class, struct,\nimpl and typedef. This includes storage.type for backwards\ncompatibility with older color schemes."}, {"word": "storage.type.union keyword.declaration.union", "info": "Keywords for classes, structs, interfaces, etc should use the following scopes \u2013\nthis list is not exhaustive. Example keywords include class, struct,\nimpl and typedef. This includes storage.type for backwards\ncompatibility with older color schemes."}, {"word": "storage.type.trait keyword.declaration.trait", "info": "Keywords for classes, structs, interfaces, etc should use the following scopes \u2013\nthis list is not exhaustive. Example keywords include class, struct,\nimpl and typedef. This includes storage.type for backwards\ncompatibility with older color schemes."}, {"word": "storage.type.interface keyword.declaration.interface", "info": "Keywords for classes, structs, interfaces, etc should use the following scopes \u2013\nthis list is not exhaustive. Example keywords include class, struct,\nimpl and typedef. This includes storage.type for backwards\ncompatibility with older color schemes."}, {"word": "storage.type.impl keyword.declaration.impl", "info": "Keywords for classes, structs, interfaces, etc should use the following scopes \u2013\nthis list is not exhaustive. Example keywords include class, struct,\nimpl and typedef. This includes storage.type for backwards\ncompatibility with older color schemes."}, {"word": "storage.type keyword.declaration.type", "info": "Keywords for classes, structs, interfaces, etc should use the following scopes \u2013\nthis list is not exhaustive. Example keywords include class, struct,\nimpl and typedef. This includes storage.type for backwards\ncompatibility with older color schemes."}, {"word": "string.quoted.single", "info": "Basic strings use the one of the following scopes, based on the type of quotes\nused:"}, {"word": "string.quoted.double", "info": "Basic strings use the one of the following scopes, based on the type of quotes\nused:"}, {"word": "string.quoted.triple", "info": "Basic strings use the one of the following scopes, based on the type of quotes\nused:"}, {"word": "string.quoted.other", "info": "Strings that used unconventional quotes, such as < and > with C imports,\nshould use:"}, {"word": "string.unquoted", "info": "Unquoted strings, such as in Shell and Batch File, should use:"}, {"word": "string.regexp", "info": "Regular expression literals should use:"}, {"word": "support.constant", "info": "Elements provided by a base framework should use one of the following scopes.\nExamples include Cocoa within Objective-C, or the browser/Node within\nJavaScript."}, {"word": "support.function", "info": "Elements provided by a base framework should use one of the following scopes.\nExamples include Cocoa within Objective-C, or the browser/Node within\nJavaScript."}, {"word": "support.module", "info": "Elements provided by a base framework should use one of the following scopes.\nExamples include Cocoa within Objective-C, or the browser/Node within\nJavaScript."}, {"word": "support.type", "info": "While also used for base frameworks, many syntaxes apply these to scopes\nunrecognized classes and types, effectively scoping all user constructs."}, {"word": "support.class", "info": "While also used for base frameworks, many syntaxes apply these to scopes\nunrecognized classes and types, effectively scoping all user constructs."}, {"word": "text.html", "info": "HTML should use the following scope. Variants for this scope are different than\nother scopes, in that the variant is always added after the .html, such as\ntext.html.basic or text.html.markdown."}, {"word": "text.xml", "info": "XML should use:"}, {"word": "variable.other", "info": "A generic variable should use the following scope. Some languages use the\nreadwrite variant for contrast with the constant variant discussed\nbelow."}, {"word": "variable.other.readwrite", "info": "A generic variable should use the following scope. Some languages use the\nreadwrite variant for contrast with the constant variant discussed\nbelow."}, {"word": "variable.other.constant", "info": "Immutable variables, often via a const modifier, should receive the\nfollowing scope. Depending on the language and semantics,\nentity.name.constant may be a better choice."}, {"word": "variable.language", "info": "Reserved variable names that are specified by the language, such as this,\nself, super, etc. should use:"}, {"word": "variable.parameter", "info": "Parameters to a function or methods should use the following scope. This may\nalso be used for other parameter-like variables, such as receivers or named\nreturn values in Go."}, {"word": "variable.other.member", "info": "Fields, properties, members and attributes of a class or other data structure\nshould use:"}, {"word": "variable.function", "info": "Function and method names should be scoped using the following, but only when\nthey are being invoked. When defined, they should use\nentity.name.function."}, {"word": "variable.annotation", "info": "The final label in an identifier that is part of an annotation should use the\nfollowing. For the entire identifier, the meta.path scope should be used.\nThe entire annotation should get meta.annotation."}]